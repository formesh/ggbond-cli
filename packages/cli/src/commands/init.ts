import prompts from 'prompts';
import { join, dirname } from 'path';
import {
  readFileSync,
  writeFileSync,
  mkdirSync,
  existsSync,
  cpSync,
  unlinkSync,
} from 'fs';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// é¡¹ç›®åˆå§‹åŒ–å‡½æ•°
export async function initProject(projectName: string, options: any) {
  let name = projectName;
  // å¦‚æœæ²¡æœ‰æä¾›é¡¹ç›®åç§°ï¼Œé€šè¿‡äº¤äº’å¼æç¤ºè·å–
  if (!name) {
    const response = await prompts({
      type: 'text',
      name: 'projectName',
      message: 'è¯·è¾“å…¥é¡¹ç›®åç§°:',
      validate: value => (value.trim() ? true : 'é¡¹ç›®åç§°ä¸èƒ½ä¸ºç©º'),
    });
    if (!response.projectName) {
      console.log('âŒ æ“ä½œå·²å–æ¶ˆ');
      return;
    }
    name = response.projectName;
  }

  // é€‰æ‹©æ¡†æ¶
  const frameworkResponse = await prompts({
    type: 'select',
    name: 'framework',
    message: 'é€‰æ‹©é¡¹ç›®æ¡†æ¶:',
    choices: [
      { title: 'React', value: 'react' },
      { title: 'Vue', value: 'vue' },
      { title: 'Vanilla', value: 'vanilla' },
    ],
    initial: 0,
  });

  if (!frameworkResponse.framework) {
    console.log('âŒ æ“ä½œå·²å–æ¶ˆ');
    return;
  }

  // é€‰æ‹©æ˜¯å¦ä½¿ç”¨ TypeScript
  const typescriptResponse = await prompts({
    type: 'confirm',
    name: 'useTypeScript',
    message: 'æ˜¯å¦ä½¿ç”¨ TypeScript?',
    initial: true,
  });
  if (typescriptResponse.useTypeScript === undefined) {
    console.log('âŒ æ“ä½œå·²å–æ¶ˆ');
    return;
  }
  // æ ¹æ®é€‰æ‹©ç¡®å®šæ¨¡æ¿
  const template = `template-${frameworkResponse.framework}${typescriptResponse.useTypeScript ? '-ts' : ''}`;
  console.log(`ğŸš€ æ­£åœ¨åˆ›å»ºé¡¹ç›®: ${name}`);
  console.log(`ğŸ“¦ ä½¿ç”¨æ¨¡æ¿: ${template}`);
  // åˆ›å»ºé¡¹ç›®ç›®å½•
  const projectPath = join(process.cwd(), name);
  if (existsSync(projectPath)) {
    const overwrite = await prompts({
      type: 'confirm',
      name: 'overwrite',
      message: `ç›®å½• ${name} å·²å­˜åœ¨ï¼Œæ˜¯å¦è¦†ç›–ï¼Ÿ`,
      initial: false,
    });

    if (!overwrite.overwrite) {
      console.log('âŒ æ“ä½œå·²å–æ¶ˆ');
      return;
    }
  }
  mkdirSync(projectPath, { recursive: true });
  // ç”Ÿæˆé¡¹ç›®æ–‡ä»¶
  await generateProjectFiles(projectPath, name, template);
  console.log('âœ… é¡¹ç›®åˆ›å»ºæˆåŠŸ!');
  console.log(`\nğŸ“ é¡¹ç›®è·¯å¾„: ${projectPath}`);
  console.log('\nğŸ¯ ä¸‹ä¸€æ­¥:');
  console.log(`   cd ${name}`);
  console.log('   npm install');
  console.log('   npm run dev');
}

// ç”Ÿæˆé¡¹ç›®æ–‡ä»¶
async function generateProjectFiles(
  projectPath: string,
  projectName: string,
  template: string
) {
  // è·å–æ¨¡æ¿è·¯å¾„
  const templatePath = join(__dirname, '../../templates', template);
  if (!existsSync(templatePath)) {
    throw new Error(`æ¨¡æ¿ ${template} ä¸å­˜åœ¨`);
  }
  // å¤åˆ¶æ¨¡æ¿æ–‡ä»¶
  cpSync(templatePath, projectPath, { recursive: true });
  // æ›´æ–° package.json ä¸­çš„é¡¹ç›®åç§°
  const packageJsonPath = join(projectPath, 'package.json');
  if (existsSync(packageJsonPath)) {
    const packageJson = JSON.parse(readFileSync(packageJsonPath, 'utf-8'));
    packageJson.name = projectName;
    packageJson.description = `${projectName} - Generated by GGBond CLI`;
    writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 2));
  }
  // é‡å‘½å _gitignore ä¸º .gitignore
  const gitignorePath = join(projectPath, '_gitignore');
  const newGitignorePath = join(projectPath, '.gitignore');
  if (existsSync(gitignorePath)) {
    const gitignoreContent = readFileSync(gitignorePath, 'utf-8');
    writeFileSync(newGitignorePath, gitignoreContent);
    // åˆ é™¤åŸæ–‡ä»¶
    unlinkSync(gitignorePath);
  }
}
